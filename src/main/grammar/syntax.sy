%{
/*
 ===============================================================================
 Copyright (c) 1985, 2012, Jaime Garza
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.
     * Neither the name of Jaime Garza nor the
       names of its contributors may be used to endorse or promote products
       derived from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ===============================================================================
*/
package me.jaimegarza.syntax.generator;

import java.io.IOException;
import java.util.Arrays;

import me.jaimegarza.syntax.ParsingException;
import me.jaimegarza.syntax.definition.Associativity;
import me.jaimegarza.syntax.definition.ErrorToken;
import me.jaimegarza.syntax.definition.NonTerminal;
import me.jaimegarza.syntax.definition.Rule;
import me.jaimegarza.syntax.definition.RuleItem;
import me.jaimegarza.syntax.definition.Symbol;
import me.jaimegarza.syntax.definition.Terminal;
import me.jaimegarza.syntax.definition.Type;
import me.jaimegarza.syntax.env.Environment;

/**
 * Parser for a grammar.<p>
 * TODO: P1-This parser will be replaced for a generated one (which
 * probably will be created from this one)
 *
 * Phases:
 * 
 * <ol>
 *   <li><b>Code Parser</b> (This Phase)
 *   <li>Structural Analysis
 *   <li>Table Generation
 *   <li>Writing Code
 * </ol>
 * @author jaimegarza@gmail.com
 *
 */
public class SyntaxCodeParser extends AbstractCodeParser {
%}

%union {
    public int stateNumber;
    public int value;
    public boolean mustClose;
    public String id;
    public String regex;

    StackElement(int state, int value, boolean mustClose, String id, String regex) {
      super();
      this.stateNumber = state;
      this.value = value;
      this.mustClose = mustClose;
      this.id = id;
      this.regex = regex;
    }

    @Override
    public String toString() {
      return "state:" + stateNumber + ", value:" + value + ", mustClose:" + mustClose + ", id:" + id;
    }
}

%token            TOK_MARK      256: "'%%'"
%token            TOK_START     257: "'%start'"
%token  <s>       TOK_TOKEN     258: "Token"
%token            TOK_TYPE      259: "'%type'"
%token            TOK_UNION     260: "'%union'"
%token  <s.id>    TOK_TYPENAME  261: "Type definition"
%token            TOK_TERM      262: "'%token'"
%token            TOK_LEFT      263: "'%left'"
%token            TOK_RIGHT     264: "'%right'"
%token            TOK_BINARY    265: "'%binary'"
%token            TOK_ERRDEF    266: "'%error'"
%token  <s.value> TOK_NUM       267: "Number"
%token            TOK_PREC      268: "'%prec'"
%token            TOK_NAME      269: "'%name'"
%token            TOK_ERROR     270: "Error"
%token            TOK_LEXER     271: "%lexer"

%token <node>     TOK_RX_PIPE   272: "'|'"
%token            TOK_RX_LPAR   273: "'('"
%token            TOK_RX_RPAR   274: "')'"
%token <node>     TOK_RX_STAR   275: "'*'" 
%token <node>     TOK_RX_PLUS   276: "'+'" 
%token <node>     TOK_RX_HUH    277: "'?'" 
%token <node>     TOK_RX_ANY    278: "'.'"
%token <node>     TOK_RX_CHARS  279: "Character or set of characters"

%token            ';'              : "Semicolon"
%token            ':'              : "Colon"
%token            ','              : "Comma"
%token            '|'              : "Rule separator ('|')"
%token            '('              : "Opening parenthesis"
%token            ')'              : "Closing parenthesis"
%token            '/'              : "Regular expression marker ('/')"

%type   <s.value> Number;
%type   <s>       Precedence;
%type   <s>       ErrInfo;
%type   <node>    LexicAction;

%type <node>      BasicElement;
%type <node>      ConcatElement;
%type <node>      RegExp;

%name Declarations                  : "declarations";
%name Declaration                   : "a declaration";
%name Actions                       : "code section";
%name Precedence                   : "a token definition";
%name Symbol                       : "token, precedence declaration or '='";
%name GrammarRule                        : "parser rule definition";
%name LexicAction                       : "lexical token definition";

%name RegExp                        : "regular expression";
%name ConcatElement                 : "operator expression";
%name BasicElement                  : "basic element";

%union {
    STACK s;
    PREGEXNODE node;
}

%start Descriptor

%error ';'

%%
Descriptor   :  Declarations =TokenEndAction(); TOK_MARK Productions Actions
             |  =TokenEndAction(); TOK_MARK Productions Actions
             ;

Actions      :                              = {
                                                if(!RuleEndAction())
                                                    return FALSE;
                               
                                                bActFinales = FALSE;
                                            }
             |  TOK_MARK                   = {
                                                if(!RuleEndAction())
                                                    return FALSE;
                                                bActFinales = TRUE;
                                            }
             ;

Declarations :  Declarations Declaration
             |  Declaration
             ;

Declaration  :  ';'
             |  TOK_START TOK_TOKEN         = {
                                                if(pGStart){
                                                    Error(LINE_SIS, ERR_START2, pGStart->id);
                                                    return FALSE;
                                                }
                                                if(!(where = LookID(pTtable, $2.id))){
                                                    if(!(where = LookID(pNTtable, $2.id))){
                                                        if( !(pNTtable = NewID(pNTtable, $2.id))){
                                                            Error(LINE_SIS, ERR_NOM);
                                                            return FALSE;
                                                        }
                                                        where = LookID(pNTtable, $2.id);
                                                    }
                                                    where->count--;
                                                    pGStart = where;
                                                }else{
                                                    Error(LINE_SIS, ERR_START, $2.id);
                                                    return FALSE;
                                                }
                                            }
             |  TOK_LEXCODE TOK_TOKEN 
             |  TOK_TYPE TOK_TYPENAME Tokens
             |  TOK_NAME TokenNames
             |  TOK_UNION                   = if(!DeclUnion()) return FALSE;
             |  PrecDef Definition          = pCurType = NULL;
             |  '{'                         = if(!DeclAction()) return FALSE;
             |  TOK_LEXER Equals TOK_TOKEN
             ;

PrecDef      :  TOK_TERM                    = {
                                                RuleAsoc = 1;
                                                bErrorToken = FALSE;
                                            }
             |  TOK_LEFT                    = {
                                                RulePrec++;
                                                RuleAsoc = 1;
                                                bErrorToken = FALSE;
                                            }
             |  TOK_RIGHT                   = {
                                                RulePrec++;
                                                RuleAsoc = 2;
                                                bErrorToken = FALSE;
                                            }
             |  TOK_BINARY                  = {
                                                RulePrec++;
                                                RuleAsoc = 3;
                                                bErrorToken = FALSE;
                                            }
             |  TOK_ERRDEF                  = {
                                                RuleAsoc = 0;
                                                bErrorToken = TRUE;
                                            }
             ;

Tokens       :  Tokens TOK_TOKEN            = return DeclareOneNonTerminal(StxStack[pStxStack-2].s.id, $2.id);
             |  Tokens ',' TOK_TOKEN        = return DeclareOneNonTerminal(StxStack[pStxStack-3].s.id, $3.id);
             |  TOK_TOKEN                   = return DeclareOneNonTerminal(StxStack[pStxStack-1].s.id, $1.id);
             ;

TokenNames   :  TokenNames TOK_TOKEN ':' TOK_TOKEN       = return NameOneNonTerminal($2.id, $4.id);
             |  TokenNames ',' TOK_TOKEN ':' TOK_TOKEN   = return NameOneNonTerminal($3.id, $5.id);
             |  TOK_TOKEN ':' TOK_TOKEN                  = return NameOneNonTerminal($1.id, $3.id);
             ;

Definition   :  Type Precedences
             ;

Precedences  :  Precedences ',' Precedence
             |  Precedences Precedence
             |  Precedence
             ;

Precedence   :  TOK_TOKEN Number ErrInfo LexicAction = {
                                                if($2 != -1)
                                                    $$.value = $2;
                                                if(!(where = LookID(pTtable, $1.id))){
                                                    if( !(pTtable = NewID(pTtable, $1.id))){
                                                        Error(LINE_SIS, ERR_NOM);
                                                        return FALSE;
                                                    }
                                                    where = LookID(pTtable, $1.id);
                                                }
                                                where->count--;
                                                if(RuleAsoc){
                                                    if(where->associative != ASC_NO){
                                                        Error(LINE_SIS, ERR_PRECASOC);
                                                        return FALSE;
                                                    }
                                                    where->precedence  = RulePrec;
                                                    where->associative = RuleAsoc;
                                                }
                                                if(bErrorToken)
                                                    where->is_error = bErrorToken;
                                                if(pCurType)
                                                    where->type = pCurType;
                                                if($$.value >= 0){
                                                    PIDENT cual;
                                                    if(where->token != -1)
                                                        Error(LINE_SIS, ERR_TOKREDEF, where->id);
                                                    for(cual = pTtable; cual; cual=cual->next)
                                                        if(cual != where && cual->token == $$.value){
                                                            Error(LINE_SIS, ERR_TOKREUSED, $$.value, cual->id);
                                                            return FALSE;
                                                        }
                                                    where->token = $$.value;
                                                }
                                                if ($3.id[0]) {
                                                    strcpy(where->name, $3.id);
                                                }
                                                if ($4 != NULL) {
                                                    SetEndToken($4, where->id);
                                                }
                                            }
             ;

Number       :  TOK_NUM
             |                              = $$ = -1;
             ;

ErrInfo      : ':' TOK_TOKEN                =  strcpy($$.id, $2.id);
             |
             ;

LexicAction  : Equals TOK_TOKEN             = $$ = NULL;
             | Slash RegExp Slash           = $$ = AddTree($2);
             |                              = $$ = NULL;
             ;

Slash        : '/' TOK_TOKEN                
             ;

RegExp        : RegExp ConcatElement        = $$ = SequentialNode($1, $2);
              | RegExp TOK_RX_PIPE ConcatElement = $$ = AlternateNode($1, $3);
              | ConcatElement
              ;
         
ConcatElement : BasicElement TOK_RX_STAR    = $$ = ZeroOrManyNode($1);
              | BasicElement TOK_RX_PLUS    = $$ = OneOrManyNode($1);
              | BasicElement TOK_RX_HUH     = $$ = ZeroOrOneNode($1);
              | BasicElement
              ;
              
BasicElement  : TOK_RX_LPAR RegExp TOK_RX_RPAR = $$ = $2;
              | TOK_CHARS                      = CharNode($$);
              | TOK_RX_ANY                     = AnyNode();
              ;

Equals       : '='                          = TokenAction();
             ;

Type         :  TOK_TYPENAME                = {
                                                if( !(pCurType = NewType($1))){
                                                    Error(LINE_SIS, ERR_NOM);
                                                    return FALSE;
                                                }
                                            }
             |                              = pCurType = NULL;
             ;


Productions  :  Productions TOK_TOKEN ':' Rules ';'  = return DeclareRules($2.id);
             |  TOK_TOKEN ':' Rules ';'               = return DeclareRules($1.id);
             ;

Rules        :  Rules '|' GrammarRule           = {
                                                if(!NewRule()){
                                                    Error(LINE_SIS, ERR_NOM);
                                                    return FALSE;
                                                }
                                                bActionDone = FALSE;
                                            }
             |  GrammarRule                      = {
                                                if(!NewRule()){
                                                    Error(LINE_SIS, ERR_NOM);
                                                    return FALSE;
                                                }
                                                stx = pSintax;
                                                while (stx->next)
                                                    stx = stx->next;
                                                pTope = stx;
                                                bActionDone = FALSE;
                                            }
             ;

GrammarRule  :  Rule
             |                              = {
                                                pRule = NULL;
                                                bActionDone = FALSE;
                                            }
             ;

Rule         :  Rule Symbol
             |  Symbol
             ;

Symbol       :  TOK_TOKEN                    = {
                                                            if(!$1.id[0])
                                                                break;
                                                            if(firsttok){
                                                                RulePrec = RuleAsoc = 0;
                                                                firsttok = FALSE;
                                                            }
                                                            if(bActionDone){
                                                                aRule = pRule;
                                                                pRule = NULL;
                                                                i = RulePrec;
                                                                j = RuleAsoc;
                                                                RulePrec = 0;
                                                                if(!NewRule()){
                                                                    Error(LINE_SIS, ERR_NOM);
                                                                    return FALSE;
                                                                }
                                                                RulePrec = i;
                                                                RuleAsoc = j;
                                                                pRule = aRule;
                                                                for(stx = pSintax; stx->next; stx=stx->next);
                                                                sprintf(regla, "Sys$Prod%d", RuleCounter-1);
                                                                if( !(pNTtable = NewID(pNTtable, regla))){
                                                                    Error(LINE_SIS, ERR_NOM);
                                                                    return FALSE;
                                                                }
                                                                where = pNTtable;
                                                                while (strcmp(where->id, regla))
                                                                    where = where->next;
                                                                where->used = NOTERMINAL;
                                                                stx->id = where;
                                                                where->count++;
                                                                where->precedence = TRUE; /* usado como no terminal */
                                                                if(!NewItem(where)){
                                                                    Error(LINE_SIS, ERR_NOM);
                                                                    return FALSE;
                                                                }
                                                                bActionDone = FALSE;
                                                            }
                                                            if(!(where = LookID(pNTtable, $1.id))){
                                                                if(where = LookID(pTtable,$1.id)){
                                                                    RulePrec = where->precedence;
                                                                    RuleAsoc = where->associative;
                                                                }else{
                                                                    if($1.must_close && $1.value >= 0){
                                                                        if( !(pTtable = NewID(pTtable, $1.id))){
                                                                            Error(LINE_SIS, ERR_NOM);
                                                                            return FALSE;
                                                                        }
                                                                        where = LookID(pTtable, $1.id);
                                                                        if($1.value >=0){
                                                                            PIDENT cual;
                                                                            for(cual = pTtable; cual; cual=cual->next)
                                                                                if(cual != where && cual->token == $1.value){
                                                                                    Error(LINE_SIS, ERR_TOKREUSED, $1.value, cual->id);
                                                                                    return FALSE;
                                                                                }
                                                                            where->token = $1.value;
                                                                            where->used = TERMINAL;
                                                                        }
                                                                    }else{
                                                                        if(!(pNTtable = NewID(pNTtable, $1.id))){
                                                                            Error(LINE_SIS, ERR_NOM);
                                                                            return FALSE;
                                                                        }
                                                                        noterminals++;
                                                                        for(where = pNTtable; strcmp(where->id, $1.id); where = where->next);
                                                                        where->used = NOTERMINAL;
                                                                        where->count++;
                                                                    }
                                                                }
                                                            }
                                                            if(!NewItem(where)){
                                                                Error(LINE_SIS, ERR_NOM);
                                                                return FALSE;
                                                            }
                                                        }
             |  TOK_PREC TOK_TOKEN                      = {
                                                            if(!(where = LookID(pNTtable, $2.id))){
                                                                if(!(where = LookID(pTtable,$2.id))){
                                                                    Error(LINE_SIS, ERR_BADTOKEN2, $2.id);
                                                                    return FALSE;
                                                                }else{
                                                                    RulePrec = where->precedence;
                                                                    RuleAsoc = where->associative;
                                                                }
                                                            }else{
                                                                Error(LINE_SIS, ERR_BADTOKEN2, $2.id);
                                                                return FALSE;
                                                            }
                                                        }
             |  '='                                     = {
                                                            for(aRule = pRule, i = 0; aRule; aRule=aRule->next, i++);
                                                            if(!RuleAction(RuleCounter, i, snt))
                                                                return FALSE;
                                                            bActionDone = TRUE;
                                                        }
             ;

%%

  /**
   * Get next token
   * 
   * @return the next token, changing mode as needed
   */
  protected int StxScan() throws IOException {
    int rc;
  
    if (isRegex) {
      rc = getRegexSymbol();
      if (environment.isVerbose()) {
        System.out.printf("RegexScanner: %d\n", rc);
      }
    } else {
      rc = getNormalSymbol();
      StxValue = new StackElement(-1, tokenNumber, mustClose, runtimeData.currentStringValue, null);
      if (environment.isDebug()) {
        System.out.printf("* StdScanner: %s(%d) {%s}\n",
            (rc >= 256 ? tokenNames[rc - 256] : "\"" + Character.toString((char) rc) + "\""), rc,
            StxValue != null ? StxValue.toString() : "");
      }
    }
    return rc;
  }

  /**
   * report an error
   * 
   * @param StxState state of the error
   * @param StxSym causing token
   * @param pStxStack the position in the stack when the error happened
   * @return
   */
  protected int StxError(int StxState, int StxSym, int pStxStack) {
    int msg = StxParsingTable[StxState].msg;
    if (msg >= 0) {
      environment.error(-1, "Syntax error %d :\'%s\'.", StxState, StxErrorTable[msg]);
    } else {
      System.err.printf("%s(%05d) : Unknown error on state %d\n", environment.getSourceFile().toString(),
          runtimeData.lineNumber + 1, StxState);
    }
    isError = true;
    return 0; /*
               * with actions, it recovers weird. Need to change the action
               * stuff to the scanner
               */
  }

  @Override
  public int getRegexSymbol() throws IOException {
    char c2;
  
    if (isEqual) {
      isEqual = false;
      runtimeData.currentStringValue = "";
      return TOK_TOKEN;
    }
  
    if (runtimeData.currentCharacter == '|') {
      getCharacter();
      return TOK_RX_PIPE;
    }
    if (runtimeData.currentCharacter == '(') {
      getCharacter();
      return TOK_RX_LPAR;
    }
    if (runtimeData.currentCharacter == ')') {
      getCharacter();
      return TOK_RX_RPAR;
    }
    if (runtimeData.currentCharacter == '*') {
      getCharacter();
      return TOK_RX_STAR;
    }
    if (runtimeData.currentCharacter == '+') {
      getCharacter();
      return TOK_RX_PLUS;
    }
    if (runtimeData.currentCharacter == '?') {
      getCharacter();
      return TOK_RX_HUH;
    }
    if (runtimeData.currentCharacter == '.') {
      getCharacter();
      return TOK_RX_ANY;
    }
    if (runtimeData.currentCharacter == '/') {
      isRegex = false;
      isEqual = true;
      getCharacter();
      return '/';
    }
  
    if (runtimeData.currentCharacter == '\\') {
      getCharacter();
      c2 = decodeEscape();
      if (c2 == 0) {
        return '\0';
      }
    }
    /*
     * StxValue.node = malloc(sizeof(REGEXNODE)); StxValue.node.parent = NULL;
     * StxValue.node.child1 = NULL; StxValue.node.child2 = NULL;
     * StxValue.node.nodeType = NODE_LEX; StxValue.node.ranges =
     * malloc(sizeof(REGEXRANGE)); StxValue.node.ranges.next = NULL;
     * StxValue.node.ranges.prev = NULL; StxValue.node.ranges.charStart = c2;
     * StxValue.node.ranges.charEnd = c2;
     */
    return TOK_CHARS;
  }

  @Override
  public int getNormalSymbol() throws IOException {
    char c2;
    String s2;
    boolean end;
  
    s2 = runtimeData.currentStringValue;
    runtimeData.currentStringValue = "";
  
    if (markers >= 2) {
      return 0;
    }
  
    if (isCurlyBrace) {
      isCurlyBrace = false;
      return ';';
    }
  
    if (isEqual) {
      isEqual = false;
      runtimeData.currentStringValue = "";
      return TOK_TOKEN;
    }
  
    while (2 > 1) {
      while (Character.isWhitespace(runtimeData.currentCharacter)) {
        getCharacter();
      }
      if (runtimeData.currentCharacter == '/') {
        if ((getCharacter()) == '*') {
          getCharacter();
          end = false;
          while (!end) {
            while (runtimeData.currentCharacter == '*') {
              if ((getCharacter()) == '/') {
                end = true;
              }
            }
            getCharacter();
          }
        } else {
          ungetCharacter(runtimeData.currentCharacter);
          runtimeData.currentCharacter = '/';
          break;
        }
      } else {
        break;
      }
    }
  
    if (runtimeData.currentCharacter == '\0') {
      return 0;
    }
  
    if (runtimeData.currentCharacter == '%' || runtimeData.currentCharacter == '\\') {
      getCharacter();
      switch (runtimeData.currentCharacter) {
        case '0':
          getCharacter();
          return TOK_TERM;
        case '<':
          getCharacter();
          return TOK_LEFT;
        case '2':
          getCharacter();
          return TOK_BINARY;
        case '>':
          getCharacter();
          return TOK_RIGHT;
        case '%':
        case '\\':
          getCharacter();
          markers++;
          return TOK_MARK;
        case '=':
          getCharacter();
          return TOK_PREC;
        case '@':
          getCharacter();
          return TOK_NAME;
        case '{':
          getCharacter();
          isCurlyBrace = true;
          return '{';
        case '!':
          getCharacter();
          return TOK_ERRDEF;
      }
      while (Character.isLetterOrDigit(runtimeData.currentCharacter)) {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      for (ReservedWord rw : RWord) {
        if (runtimeData.currentStringValue.equals(rw.word)) {
          if (rw.token == TOK_UNION) {
            isCurlyBrace = true;
          }
          return rw.token;
        }
      }
      isError = true;
      environment.error(-1, "Reserved word \'%s\' is incorrect.", runtimeData.currentStringValue);
      return TOK_ERROR;
    }
  
    if (runtimeData.currentCharacter == ';') {
      getCharacter();
      return ';';
    }
  
    if (runtimeData.currentCharacter == ',') {
      getCharacter();
      return ',';
    }
  
    if (runtimeData.currentCharacter == ':') {
      currentNonTerminalName = s2;
      getCharacter();
      return ':';
    }
  
    if (runtimeData.currentCharacter == '|') {
      getCharacter();
      return '|';
    }
  
    if (runtimeData.currentCharacter == '=') {
      getCharacter();
      isEqual = true;
      return '=';
    }
  
    if (runtimeData.currentCharacter == '{') {
      isEqual = true;
      return '=';
    }
  
    if (runtimeData.currentCharacter == '<') {
      getCharacter();
      runtimeData.currentStringValue = "";
      while (runtimeData.currentCharacter != '\0' && runtimeData.currentCharacter != '>' && runtimeData.currentCharacter != '\n') {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      if (runtimeData.currentCharacter != '>') {
        isError = true;
        environment.error(-1, "Statement < .. > not ended.");
        return TOK_ERROR;
      }
      getCharacter();
      return TOK_TYPENAME;
    }
  
    if (runtimeData.currentCharacter == '/') {
      isRegex = true;
      isEqual = true;
      getCharacter();
      return '/';
    }
  
    if (Character.isDigit(runtimeData.currentCharacter)) {
      runtimeData.currentStringValue = "";
      while (Character.isDigit(runtimeData.currentCharacter)) {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      tokenNumber = Integer.parseInt(runtimeData.currentStringValue);
      return TOK_NUM;
    }
  
    mustClose = false;
    if (runtimeData.currentCharacter == '\'' || runtimeData.currentCharacter == '"') {
      c2 = runtimeData.currentCharacter;
      mustClose = true;
      getCharacter();
    } else {
      c2 = ':';
    }
  
    runtimeData.currentStringValue = "";
    do { /* TOKEN */
      runtimeData.currentStringValue += runtimeData.currentCharacter;
      getCharacter();
      if (runtimeData.currentCharacter == '\0') {
        break;
      }
      if (!mustClose && "%\\;,:|={< \r\t\n".indexOf(runtimeData.currentCharacter) >= 0) {
        break;
      }
    } while (runtimeData.currentCharacter != c2);
  
    if (mustClose && runtimeData.currentCharacter != c2) {
      isError = true;
      environment.error(-1, "Statement ' .. ' or \" .. \" not ended.");
      return TOK_ERROR;
    }
    tokenNumber = -1;
    if (runtimeData.currentStringValue.equals("\\a")) {
      tokenNumber = 7;
    } else if (runtimeData.currentStringValue.equals("\\b")) {
      tokenNumber = '\b';
    } else if (runtimeData.currentStringValue.equals("\\n")) {
      tokenNumber = '\n';
    } else if (runtimeData.currentStringValue.equals("\\t")) {
      tokenNumber = '\t';
    } else if (runtimeData.currentStringValue.equals("\\f")) {
      tokenNumber = '\f';
    } else if (runtimeData.currentStringValue.equals("\\r")) {
      tokenNumber = '\r';
    } else if (runtimeData.currentStringValue.length() >= 2 && runtimeData.currentStringValue.substring(0, 2).equals("\\x")) {
      int p = 2;
      tokenNumber = 0;
      while (2 > 1) {
        if (runtimeData.currentStringValue.charAt(p) >= '0' && runtimeData.currentStringValue.charAt(p) <= '9') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - '0';
        } else if (runtimeData.currentStringValue.charAt(p) >= 'A' && runtimeData.currentStringValue.charAt(p) <= 'F') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - 'A' + 10;
        } else if (runtimeData.currentStringValue.charAt(p) >= 'a' && runtimeData.currentStringValue.charAt(p) <= 'f') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - 'a' + 10;
        } else {
          break;
        }
      }
    } else if (runtimeData.currentStringValue.length() >= 2 && runtimeData.currentStringValue.substring(0, 2).equals("\\0")) {
      int p = 2;
      tokenNumber = 0;
      while (runtimeData.currentStringValue.charAt(p) >= '0' && runtimeData.currentStringValue.charAt(p) <= '7') {
        tokenNumber = tokenNumber * 8 + runtimeData.currentStringValue.charAt(p++) - '0';
      }
    }
  
    if (mustClose) {
      getCharacter();
      if (runtimeData.currentStringValue.length() == 1) {
        tokenNumber = runtimeData.currentStringValue.charAt(0);
      }
    }
  
    return TOK_TOKEN;
  }

  /**
   * Execute this phase
   * @throws ParsingException on error.  Check cause and message.
   */
  public void execute() throws ParsingException {
    if (environment.isVerbose()) {
      System.out.println("Parse");
    }
    try {
      getCharacter();
      runtimeData.lineNumber = 0;
      markers = 0;
      Terminal terminal = new Terminal("$");
      runtimeData.getTerminals().add(terminal);
      terminal.setCount(0);
      terminal.setToken(0);
      if (!StxParse() || isError) {
        throw new ParsingException("Parser returned errors.  Please see messages from parser");
      }
      reviewDeclarations();
      computeRootSymbol();
      generateTopRecoveryTable();
      finalizeSymbols();
      finalizeRules();
      generateTokenDefinitions();
      runtimeData.setNumberOfErrors(StxErrors);
      runtimeData.setFinalActions(finalActions);
    } catch (IOException e) {
      throw new ParsingException("IOError ocurred when parsing: " + e.getMessage(), e);
    }
  }
  
}