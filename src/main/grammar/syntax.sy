%{
/*
 ===============================================================================
 Copyright (c) 1985, 2012, Jaime Garza
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.
     * Neither the name of Jaime Garza nor the
       names of its contributors may be used to endorse or promote products
       derived from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ===============================================================================
*/
package me.jaimegarza.syntax.generator;

import java.io.IOException;
import java.util.Arrays;

import me.jaimegarza.syntax.ParsingException;
import me.jaimegarza.syntax.definition.Associativity;
import me.jaimegarza.syntax.definition.ErrorToken;
import me.jaimegarza.syntax.definition.NonTerminal;
import me.jaimegarza.syntax.definition.Rule;
import me.jaimegarza.syntax.definition.RuleItem;
import me.jaimegarza.syntax.definition.Symbol;
import me.jaimegarza.syntax.definition.Terminal;
import me.jaimegarza.syntax.definition.Type;
import me.jaimegarza.syntax.env.Environment;

/**
 * Parser for a grammar.<p>
 * TODO: P1-This parser will be replaced for a generated one (which
 * probably will be created from this one)
 *
 * Phases:
 * 
 * <ol>
 *   <li><b>Code Parser</b> (This Phase)
 *   <li>Structural Analysis
 *   <li>Table Generation
 *   <li>Writing Code
 * </ol>
 * @author jaimegarza@gmail.com
 *
 */
@SuppressWarnings("unused")
public class SyntaxCodeParser extends AbstractCodeParser {

  private String currentTypeName = null;

  public SyntaxCodeParser(Environment env) {
    super(env);
  }
  
%}

%declare <stateNumber>
%declare <value>
%declare <mustClose>
%declare <id>
%declare <regex>
%stack {
    public int stateNumber;
    public int value;
    public boolean mustClose;
    public String id;
    public String regex;

    StackElement(int state, int value, boolean mustClose, String id, String regex) {
      super();
      this.stateNumber = state;
      this.value = value;
      this.mustClose = mustClose;
      this.id = id;
      this.regex = regex;
    }

    @Override
    public String toString() {
      return "state:" + stateNumber + ", value:" + value + ", mustClose:" + mustClose + ", id:" + id;
    }
}

%token            MARK      256: "'%%'"
%token            START     257: "'%start'"
%token  <id>      TOKEN     258: "Token"
%token            TYPE      259: "'%type'"
%token            UNION     260: "'%union'"
%token  <id>      TYPENAME  261: "Type definition"
%token            TERM      262: "'%token'"
%token            LEFT      263: "'%left'"
%token            RIGHT     264: "'%right'"
%token            BINARY    265: "'%binary'"
%token            ERRDEF    266: "'%error'"
%token  <value>   NUM       267: "Number"
%token            PREC      268: "'%prec'"
%token            NAME      269: "'%name'"
%token            ERROR     270: "Error"
%token            LEXER     271: "%lexer"
%token            DECLARE   272: "%declare"

%token <regex>    RX_PIPE   273: "'|'"
%token            RX_LPAR   274: "'('"
%token            RX_RPAR   275: "')'"
%token <regex>    RX_STAR   276: "'*'" 
%token <regex>    RX_PLUS   277: "'+'" 
%token <regex>    RX_HUH    278: "'?'" 
%token <regex>    RX_ANY    279: "'.'"
%token <regex>    RX_CHARS  280: "Character or set of characters"
%token            LEXCODE   290: "lexical code"
%token            CHARS     291: "regular expression characters"

%token            ';'              : "semicolon"
%right            ':'              : "colon"
%right            '='              : "equals sign"
%token            ','              : "comma"
%token            '|'              : "rule separator ('|')"
%token            '('              : "opening parenthesis"
%token            ')'              : "closing parenthesis"
%token            '/'              : "regular expression marker ('/')"

%type   <value>   Number;
%type   <value>   Precedence;
%type   <id>      ErrInfo;
%type   <regex>   LexicAction;

%type   <regex>   BasicElement;
%type   <regex>   ConcatElement;
%type   <regex>   RegExp;

%name Declarations                  : "declarations";
%name Declaration                   : "a declaration";
%name Actions                       : "code section";
%name Precedence                    : "a token definition";
%name Symbol                        : "token, precedence declaration or '='";
%name GrammarRule                   : "parser rule definition";
%name LexicAction                   : "lexical token definition";
%name Name                          : "a token:name pair";
%name RegExp                        : "regular expression";
%name ConcatElement                 : "operator expression";
%name BasicElement                  : "basic element";

%start Descriptor

%error ';'

%%
Descriptor   :  Declarations DeclMarker Productions Actions
             |  DeclMarker  Productions Actions
             ;
             
DeclMarker   : MARK                         = generateLexerFooter();
             ;

Actions      :                              = {
                                                generateCodeGeneratorFooter();
                                                finalActions = false;
                                              }
             |  MARK                        = {
                                                generateCodeGeneratorFooter();
                                                finalActions = true;
                                              }
             ;

Declarations :  Declarations Declaration
             |  Declaration
             ;

Declaration  :  ';'
             |  START TOKEN                 = if (!declareStart($TOKEN)) return false;
             |  LEXCODE TOKEN 
             |  TYPE TYPENAME               = currentTypeName = $TYPENAME;
                         Tokens             = currentTypeName = null;
             |  DECLARE TYPENAME            = declareOneType($TYPENAME);
             |  NAME TokenNames
             |  UNION                       = if (!generateStructure()) return false;
             |  PrecDef Definition          = currentType = null;
             |  '{'                         = if (!generateDeclaration()) return false;
             |  LEXER Equals TOKEN
             ;

PrecDef      :  TERM                        = {
                                                ruleAssociativity = Associativity.NONE;
                                                isErrorToken = false;
                                              }
             |  LEFT                        = {
                                                rulePrecedence++;
                                                ruleAssociativity = Associativity.LEFT;
                                                isErrorToken = false;
                                              }
             |  RIGHT                       = {
                                                rulePrecedence++;
                                                ruleAssociativity = Associativity.RIGHT;
                                                isErrorToken = false;
                                              }
             |  BINARY                      = {
                                                rulePrecedence++;
                                                ruleAssociativity = Associativity.BINARY;
                                                isErrorToken = false;
                                              }
             |  ERRDEF                      = {
                                                ruleAssociativity = Associativity.NONE;
                                                isErrorToken = true;
                                              }
             ;

Tokens       :  Tokens ',' TOKEN            = if (!declareOneNonTerminal(currentTypeName, $3)) return false;
             |  TOKEN                       = if (!declareOneNonTerminal(currentTypeName, $1)) return false;
             ;

TokenNames   :  TokenNames ',' Name
             |  Name
             ;
             
Name         : TOKEN ':' TOKEN              = if (!nameOneNonTerminal($1, $3)) return false;
             ;

Definition   :  Type Precedences
             ;

Precedences  :  Precedences ',' Precedence
             |  Precedence
             ;

Precedence   :  TOKEN Number ErrInfo
                                LexicAction = {
                                                if ($2 != -1) {
                                                  $$ = $2;
                                                }
                                                if (!declareOneTerminal($1, isErrorToken, ruleAssociativity, rulePrecedence, currentType, $$, $3)) return false;
                                              }
             ;

Number       :  NUM
             |                              = $<>$ = new StackElement(0, -1, false, "", null);
             ;

ErrInfo      : ':' TOKEN                    = $$ = $2; 
             | %prec ':'                    = $<>$ = new StackElement(0, 0, false, "", null);
             ;

LexicAction  : Equals TOKEN                 = $$ = null;
             | Slash RegExp Slash           = //$$ = AddTree($2);
             | %prec '='                    = $<>$ = new StackElement(0, -1, false, "", null);
             ;

Slash        : '/' TOKEN                
             ;

RegExp        : RegExp ConcatElement        = //$$ = SequentialNode($1, $2);
              | RegExp RX_PIPE ConcatElement= //$$ = AlternateNode($1, $3);
              | ConcatElement
              ;
         
ConcatElement : BasicElement RX_STAR        = //$$ = ZeroOrManyNode($1);
              | BasicElement RX_PLUS        = //$$ = OneOrManyNode($1);
              | BasicElement RX_HUH         = //$$ = ZeroOrOneNode($1);
              | BasicElement
              ;
              
BasicElement  : RX_LPAR RegExp RX_RPAR      = $$ = $2;
              | CHARS                       = //CharNode($$);
              | RX_ANY                      = //AnyNode();
              ;

Equals       : '='                          = generateLexerCode();
             ;

Type         :  TYPENAME                    = {
                                                currentType = new Type($1);
                                                if (runtimeData.getTypes().contains(currentType)) {
                                                  currentType = runtimeData.getTypes().get(runtimeData.getTypes().indexOf(currentType));
                                                } else {
                                                  runtimeData.getTypes().add(currentType);
                                                }
                                              }
             |                              = currentType = null;
             ;


Productions  :  Productions TOKEN ':' Rules ';'  = if (!setLeftHandOfLastRule($2)) return false;
             |  TOKEN ':' Rules ';'              = if (!setLeftHandOfLastRule($1)) return false;
             ;

Rules        :  Rules '|' GrammarRule       = {
                                                newRule();
                                                bActionDone = false;
                                              }
             |  GrammarRule                 = {
                                                newRule();
                                                currentRuleIndex = runtimeData.getRules().size() - 1;
                                                bActionDone = false;
                                              }
             ;

GrammarRule  :  Rule
             |                              = {
                                                bActionDone = false;
                                              }
             ;

Rule         :  Rule Symbol
             |  Symbol
             ;

Symbol       :  TOKEN                       = {
                                                if ($TOKEN.length() == 0) {
                                                  break;
                                                }
                                                if (!declareOneItem($TOKEN, $<value>TOKEN, $<mustClose>TOKEN)) return false;
                                              }
             |  PREC TOKEN                  = if(!computeAssociativityAndPrecedence($TOKEN)) return false;
             |  '='                         = {
                                                int i = runtimeData.currentRuleItems != null ? runtimeData.currentRuleItems.size() : 0;
                                                if (!ruleAction(runtimeData.getRules().size(), i, currentNonTerminalName)) {
                                                  return false;
                                                }
                                                bActionDone = true;
                                              }
             ;

%%

  /**
   * Get next token
   * 
   * @return the next token, changing mode as needed
   */
  protected int parserElement(boolean init) {
    int rc;
  
    if (init) {
      getNextChar(init);
    }
    if (isRegex) {
      rc = getRegexSymbol();
      if (environment.isVerbose()) {
        System.out.printf("RegexScanner: %d\n", rc);
      }
    } else {
      rc = getNormalSymbol();
      lexicalValue = new StackElement(-1, tokenNumber, mustClose, runtimeData.currentStringValue, null);
      if (environment.isDebug()) {
        System.out.printf("* StdScanner: %s(%d) {%s}\n",
            getTokenName(rc), rc, lexicalValue != null ? lexicalValue.toString() : "");
      }
    }
    return rc;
  }

  /**
   * report an error
   * 
   * @param StxState state of the error
   * @param StxSym causing token
   * @param pStxStack the position in the stack when the error happened
   * @return
   */
  protected int parserError(int state, int sym, int stackTop, String errorMessage) {
    if (errorMessage != null) {
      environment.error(-1, "Syntax error %d :\'%s\'.", state, errorMessage);
    } else {
      System.err.printf("%s(%05d) : Unknown error on state %d\n", environment.getSourceFile().toString(),
          runtimeData.lineNumber + 1, state);
    }
    isError = true;
    return 0; /*
               * with actions, it recovers weird. Need to change the action
               * stuff to the scanner
               */
  }
  
  /**
   * Get the next character
   * @param init indicates if this is the first call
   */
  public char getNextChar(boolean init) {
    return getCharacter();
  }

  @Override
  public int getRegexSymbol() {
    char c2;
  
    if (isEqual) {
      isEqual = false;
      runtimeData.currentStringValue = "";
      return TOKEN;
    }
  
    if (runtimeData.currentCharacter == '|') {
      getCharacter();
      return RX_PIPE;
    }
    if (runtimeData.currentCharacter == '(') {
      getCharacter();
      return RX_LPAR;
    }
    if (runtimeData.currentCharacter == ')') {
      getCharacter();
      return RX_RPAR;
    }
    if (runtimeData.currentCharacter == '*') {
      getCharacter();
      return RX_STAR;
    }
    if (runtimeData.currentCharacter == '+') {
      getCharacter();
      return RX_PLUS;
    }
    if (runtimeData.currentCharacter == '?') {
      getCharacter();
      return RX_HUH;
    }
    if (runtimeData.currentCharacter == '.') {
      getCharacter();
      return RX_ANY;
    }
    if (runtimeData.currentCharacter == '/') {
      isRegex = false;
      isEqual = true;
      getCharacter();
      return '/';
    }
  
    if (runtimeData.currentCharacter == '\\') {
      getCharacter();
      c2 = decodeEscape();
      if (c2 == 0) {
        return '\0';
      }
    }
    /*
     * StxValue.node = malloc(sizeof(REGEXNODE)); StxValue.node.parent = NULL;
     * StxValue.node.child1 = NULL; StxValue.node.child2 = NULL;
     * StxValue.node.nodeType = NODE_LEX; StxValue.node.ranges =
     * malloc(sizeof(REGEXRANGE)); StxValue.node.ranges.next = NULL;
     * StxValue.node.ranges.prev = NULL; StxValue.node.ranges.charStart = c2;
     * StxValue.node.ranges.charEnd = c2;
     */
    return CHARS;
  }

  @Override
  public int getNormalSymbol() {
    char c2;
    String s2;
    boolean end;
  
    s2 = runtimeData.currentStringValue;
    runtimeData.currentStringValue = "";
  
    if (markers >= 2) {
      return 0;
    }
  
    if (isCurlyBrace) {
      isCurlyBrace = false;
      return ';';
    }
  
    if (isEqual) {
      isEqual = false;
      runtimeData.currentStringValue = "";
      return TOKEN;
    }
  
    while (2 > 1) {
      while (Character.isWhitespace(runtimeData.currentCharacter)) {
        getCharacter();
      }
      if (runtimeData.currentCharacter == '/') {
        if ((getCharacter()) == '*') {
          getCharacter();
          end = false;
          while (!end) {
            while (runtimeData.currentCharacter == '*') {
              if ((getCharacter()) == '/') {
                end = true;
              }
            }
            getCharacter();
          }
        } else {
          ungetCharacter(runtimeData.currentCharacter);
          runtimeData.currentCharacter = '/';
          break;
        }
      } else {
        break;
      }
    }
  
    if (runtimeData.currentCharacter == '\0') {
      return 0;
    }
  
    if (runtimeData.currentCharacter == '%' || runtimeData.currentCharacter == '\\') {
      getCharacter();
      switch (runtimeData.currentCharacter) {
        case '0':
          getCharacter();
          return TERM;
        case '<':
          getCharacter();
          return LEFT;
        case '2':
          getCharacter();
          return BINARY;
        case '>':
          getCharacter();
          return RIGHT;
        case '%':
        case '\\':
          getCharacter();
          markers++;
          return MARK;
        case '=':
          getCharacter();
          return PREC;
        case '@':
          getCharacter();
          return NAME;
        case '{':
          getCharacter();
          isCurlyBrace = true;
          return '{';
        case '!':
          getCharacter();
          return ERRDEF;
      }
      while (Character.isLetterOrDigit(runtimeData.currentCharacter)) {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      for (ReservedWord rw : reservedWords) {
        if (runtimeData.currentStringValue.equals(rw.word)) {
          if (rw.token == UNION) {
            isCurlyBrace = true;
          }
          return rw.token;
        }
      }
      isError = true;
      environment.error(-1, "Reserved word \'%s\' is incorrect.", runtimeData.currentStringValue);
      return ERROR;
    }
  
    if (runtimeData.currentCharacter == ';') {
      getCharacter();
      return ';';
    }
  
    if (runtimeData.currentCharacter == ',') {
      getCharacter();
      return ',';
    }
  
    if (runtimeData.currentCharacter == ':') {
      currentNonTerminalName = s2;
      getCharacter();
      return ':';
    }
  
    if (runtimeData.currentCharacter == '|') {
      getCharacter();
      return '|';
    }
  
    if (runtimeData.currentCharacter == '=') {
      getCharacter();
      isEqual = true;
      return '=';
    }
  
    if (runtimeData.currentCharacter == '{') {
      isEqual = true;
      return '=';
    }
  
    if (runtimeData.currentCharacter == '<') {
      getCharacter();
      runtimeData.currentStringValue = "";
      while (runtimeData.currentCharacter != '\0' && runtimeData.currentCharacter != '>' && runtimeData.currentCharacter != '\n') {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      if (runtimeData.currentCharacter != '>') {
        isError = true;
        environment.error(-1, "Statement < .. > not ended.");
        return ERROR;
      }
      getCharacter();
      return TYPENAME;
    }
  
    if (runtimeData.currentCharacter == '/') {
      isRegex = true;
      isEqual = true;
      getCharacter();
      return '/';
    }
  
    if (Character.isDigit(runtimeData.currentCharacter)) {
      runtimeData.currentStringValue = "";
      while (Character.isDigit(runtimeData.currentCharacter)) {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      tokenNumber = Integer.parseInt(runtimeData.currentStringValue);
      return NUM;
    }
  
    mustClose = false;
    if (runtimeData.currentCharacter == '\'' || runtimeData.currentCharacter == '"') {
      c2 = runtimeData.currentCharacter;
      mustClose = true;
      getCharacter();
    } else {
      c2 = ':';
    }
  
    runtimeData.currentStringValue = "";
    do { /* TOKEN */
      runtimeData.currentStringValue += runtimeData.currentCharacter;
      getCharacter();
      if (runtimeData.currentCharacter == '\0') {
        break;
      }
      if (!mustClose && "%\\;,:|={< \r\t\n".indexOf(runtimeData.currentCharacter) >= 0) {
        break;
      }
    } while (runtimeData.currentCharacter != c2);
  
    if (mustClose && runtimeData.currentCharacter != c2) {
      isError = true;
      environment.error(-1, "Statement ' .. ' or \" .. \" not ended.");
      return ERROR;
    }
    tokenNumber = -1;
    if (runtimeData.currentStringValue.equals("\\a")) {
      tokenNumber = 7;
    } else if (runtimeData.currentStringValue.equals("\\b")) {
      tokenNumber = '\b';
    } else if (runtimeData.currentStringValue.equals("\\n")) {
      tokenNumber = '\n';
    } else if (runtimeData.currentStringValue.equals("\\t")) {
      tokenNumber = '\t';
    } else if (runtimeData.currentStringValue.equals("\\f")) {
      tokenNumber = '\f';
    } else if (runtimeData.currentStringValue.equals("\\r")) {
      tokenNumber = '\r';
    } else if (runtimeData.currentStringValue.length() >= 2 && runtimeData.currentStringValue.substring(0, 2).equals("\\x")) {
      int p = 2;
      tokenNumber = 0;
      while (2 > 1) {
        if (runtimeData.currentStringValue.charAt(p) >= '0' && runtimeData.currentStringValue.charAt(p) <= '9') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - '0';
        } else if (runtimeData.currentStringValue.charAt(p) >= 'A' && runtimeData.currentStringValue.charAt(p) <= 'F') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - 'A' + 10;
        } else if (runtimeData.currentStringValue.charAt(p) >= 'a' && runtimeData.currentStringValue.charAt(p) <= 'f') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - 'a' + 10;
        } else {
          break;
        }
      }
    } else if (runtimeData.currentStringValue.length() >= 2 && runtimeData.currentStringValue.substring(0, 2).equals("\\0")) {
      int p = 2;
      tokenNumber = 0;
      while (runtimeData.currentStringValue.charAt(p) >= '0' && runtimeData.currentStringValue.charAt(p) <= '7') {
        tokenNumber = tokenNumber * 8 + runtimeData.currentStringValue.charAt(p++) - '0';
      }
    }
  
    if (mustClose) {
      getCharacter();
      if (runtimeData.currentStringValue.length() == 1) {
        tokenNumber = runtimeData.currentStringValue.charAt(0);
      }
    }
  
    return TOKEN;
  }

  /**
   * Execute this phase
   * @throws ParsingException on error.  Check cause and message.
   */
  public void execute() throws ParsingException {
    if (environment.isVerbose()) {
      System.out.println("Parse");
    }
    setVerbose(environment.isDebug());
    runtimeData.lineNumber = 0;
    markers = 0;
    Terminal terminal = new Terminal("$");
    runtimeData.getTerminals().add(terminal);
    terminal.setCount(0);
    terminal.setToken(0);
    if (parse() == 0 || isError) {
      throw new ParsingException("Parser returned errors.  Please see messages from parser");
    }
    reviewDeclarations();
    computeRootSymbol();
    generateTopRecoveryTable();
    finalizeSymbols();
    finalizeRules();
    generateTokenDefinitions();
    runtimeData.setNumberOfErrors(errorCount);
    runtimeData.setFinalActions(finalActions);
  }
  
  static class ReservedWord {
    String word;
    int token;

    ReservedWord(String word, int token) {
      super();
      this.word = word;
      this.token = token;
    }
  }
  
  static final ReservedWord reservedWords[] = { 
    new ReservedWord("token", TERM),
    new ReservedWord("term", TERM), 
    new ReservedWord("left", LEFT), 
    new ReservedWord("nonassoc", BINARY),
    new ReservedWord("binary", BINARY),
    new ReservedWord("right", RIGHT), 
    new ReservedWord("prec", PREC),
    new ReservedWord("start", START), 
    new ReservedWord("type", TYPE), 
    new ReservedWord("symbol", TYPE), 
    new ReservedWord("declare", DECLARE), 
    new ReservedWord("union", UNION),
    new ReservedWord("stack", UNION), 
    new ReservedWord("class", UNION),
    new ReservedWord("struct", UNION),
    new ReservedWord("name", NAME), 
    new ReservedWord("error", ERRDEF), 
    new ReservedWord("lexer", LEXER)
  };
  
}