%{
/*
 ===============================================================================
 Copyright (c) 1985, 2012, Jaime Garza
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.
     * Neither the name of Jaime Garza nor the
       names of its contributors may be used to endorse or promote products
       derived from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ===============================================================================
*/
package me.jaimegarza.syntax.generator;

import java.io.IOException;
import java.util.Arrays;

import me.jaimegarza.syntax.ParsingException;
import me.jaimegarza.syntax.definition.Associativity;
import me.jaimegarza.syntax.definition.ErrorToken;
import me.jaimegarza.syntax.definition.NonTerminal;
import me.jaimegarza.syntax.definition.Rule;
import me.jaimegarza.syntax.definition.RuleItem;
import me.jaimegarza.syntax.definition.Symbol;
import me.jaimegarza.syntax.definition.Terminal;
import me.jaimegarza.syntax.definition.Type;
import me.jaimegarza.syntax.env.Environment;

/**
 * Parser for a grammar.<p>
 * TODO: P1-This parser will be replaced for a generated one (which
 * probably will be created from this one)
 *
 * Phases:
 * 
 * <ol>
 *   <li><b>Code Parser</b> (This Phase)
 *   <li>Structural Analysis
 *   <li>Table Generation
 *   <li>Writing Code
 * </ol>
 * @author jaimegarza@gmail.com
 *
 */
@SuppressWarnings("unused")
public class SyntaxCodeParser extends AbstractCodeParser {

  private String currentTypeName = null;

  public SyntaxCodeParser(Environment env) {
    super(env);
  }
  
%}

%stack {
    public int stateNumber;
    public int value;
    public boolean mustClose;
    public String id;
    public String regex;

    StackElement(int state, int value, boolean mustClose, String id, String regex) {
      super();
      this.stateNumber = state;
      this.value = value;
      this.mustClose = mustClose;
      this.id = id;
      this.regex = regex;
    }

    @Override
    public String toString() {
      return "state:" + stateNumber + ", value:" + value + ", mustClose:" + mustClose + ", id:" + id;
    }
}

%token            TOK_MARK      256: "'%%'"
%token            TOK_START     257: "'%start'"
%token  <id>      TOK_TOKEN     258: "Token"
%token            TOK_TYPE      259: "'%type'"
%token            TOK_UNION     260: "'%union'"
%token  <id>      TOK_TYPENAME  261: "Type definition"
%token            TOK_TERM      262: "'%token'"
%token            TOK_LEFT      263: "'%left'"
%token            TOK_RIGHT     264: "'%right'"
%token            TOK_BINARY    265: "'%binary'"
%token            TOK_ERRDEF    266: "'%error'"
%token  <value>   TOK_NUM       267: "Number"
%token            TOK_PREC      268: "'%prec'"
%token            TOK_NAME      269: "'%name'"
%token            TOK_ERROR     270: "Error"
%token            TOK_LEXER     271: "%lexer"

%token <regex>    TOK_RX_PIPE   272: "'|'"
%token            TOK_RX_LPAR   273: "'('"
%token            TOK_RX_RPAR   274: "')'"
%token <regex>    TOK_RX_STAR   275: "'*'" 
%token <regex>    TOK_RX_PLUS   276: "'+'" 
%token <regex>    TOK_RX_HUH    277: "'?'" 
%token <regex>    TOK_RX_ANY    278: "'.'"
%token <regex>    TOK_RX_CHARS  279: "Character or set of characters"
%token            TOK_LEXCODE   280: "lexical code"
%token            TOK_CHARS     290: "regular expression characters"

%token            ';'              : "semicolon"
%right            ':'              : "colon"
%right            '='              : "equals sign"
%token            ','              : "comma"
%token            '|'              : "rule separator ('|')"
%token            '('              : "opening parenthesis"
%token            ')'              : "closing parenthesis"
%token            '/'              : "regular expression marker ('/')"

%type   <value>   Number;
%type   <value>   Precedence;
%type   <id>      ErrInfo;
%type   <regex>   LexicAction;

%type   <regex>   BasicElement;
%type   <regex>   ConcatElement;
%type   <regex>   RegExp;

%name Declarations                  : "declarations";
%name Declaration                   : "a declaration";
%name Actions                       : "code section";
%name Precedence                    : "a token definition";
%name Symbol                        : "token, precedence declaration or '='";
%name GrammarRule                   : "parser rule definition";
%name LexicAction                   : "lexical token definition";
%name Name                          : "a token:name pair";
%name RegExp                        : "regular expression";
%name ConcatElement                 : "operator expression";
%name BasicElement                  : "basic element";

%start Descriptor

%error ';'

%%
Descriptor   :  Declarations DeclMarker Productions Actions
             |  DeclMarker  Productions Actions
             ;
             
DeclMarker   : TOK_MARK                     = generateLexerFooter();
             ;

Actions      :                              = {
                                                generateCodeGeneratorFooter();
                                                finalActions = false;
                                              }
             |  TOK_MARK                    = {
                                                generateCodeGeneratorFooter();
                                                finalActions = true;
                                              }
             ;

Declarations :  Declarations Declaration
             |  Declaration
             ;

Declaration  :  ';'
             |  TOK_START TOK_TOKEN         = if (!declareStart($2)) return false;
             |  TOK_LEXCODE TOK_TOKEN 
             |  TOK_TYPE TOK_TYPENAME       = currentTypeName = $2;
                         Tokens             = currentTypeName = null;
             |  TOK_NAME TokenNames
             |  TOK_UNION                   = if (!generateStructure()) return false;
             |  PrecDef Definition          = currentType = null;
             |  '{'                         = if (!generateDeclaration()) return false;
             |  TOK_LEXER Equals TOK_TOKEN
             ;

PrecDef      :  TOK_TERM                    = {
                                                ruleAssociativity = Associativity.LEFT;
                                                isErrorToken = false;
                                              }
             |  TOK_LEFT                    = {
                                                rulePrecedence++;
                                                ruleAssociativity = Associativity.LEFT;
                                                isErrorToken = false;
                                              }
             |  TOK_RIGHT                   = {
                                                rulePrecedence++;
                                                ruleAssociativity = Associativity.RIGHT;
                                                isErrorToken = false;
                                              }
             |  TOK_BINARY                  = {
                                                rulePrecedence++;
                                                ruleAssociativity = Associativity.BINARY;
                                                isErrorToken = false;
                                            }
             |  TOK_ERRDEF                  = {
                                                ruleAssociativity = Associativity.NONE;
                                                isErrorToken = true;
                                              }
             ;

Tokens       :  Tokens ',' TOK_TOKEN        = if (!declareOneNonTerminal(currentTypeName, $3)) return false;
             |  TOK_TOKEN                   = if (!declareOneNonTerminal(currentTypeName, $1)) return false;
             ;

TokenNames   :  TokenNames ',' Name
             |  Name
             ;
             
Name         : TOK_TOKEN ':' TOK_TOKEN                   = if (!nameOneNonTerminal($1, $3)) return false;
             ;

Definition   :  Type Precedences
             ;

Precedences  :  Precedences ',' Precedence
             |  Precedence
             ;

Precedence   :  TOK_TOKEN Number ErrInfo
                                LexicAction = {
                                                if ($2 != -1) {
                                                  $$ = $2;
                                                }
                                                if (!declareOneTerminal($1, isErrorToken, ruleAssociativity, rulePrecedence, currentType, $$, $3)) return false;
                                              }
             ;

Number       :  TOK_NUM
             |                              = $$ = -1;
             ;

ErrInfo      : ':' TOK_TOKEN                = $$ = $2; 
             | %prec ':'                    = $$ = "";
             ;

LexicAction  : Equals TOK_TOKEN             = $$ = null;
             | Slash RegExp Slash           = //$$ = AddTree($2);
             | %prec '='                    = $$ = null;
             ;

Slash        : '/' TOK_TOKEN                
             ;

RegExp        : RegExp ConcatElement        = //$$ = SequentialNode($1, $2);
              | RegExp TOK_RX_PIPE ConcatElement = //$$ = AlternateNode($1, $3);
              | ConcatElement
              ;
         
ConcatElement : BasicElement TOK_RX_STAR    = //$$ = ZeroOrManyNode($1);
              | BasicElement TOK_RX_PLUS    = //$$ = OneOrManyNode($1);
              | BasicElement TOK_RX_HUH     = //$$ = ZeroOrOneNode($1);
              | BasicElement
              ;
              
BasicElement  : TOK_RX_LPAR RegExp TOK_RX_RPAR = $$ = $2;
              | TOK_CHARS                      = //CharNode($$);
              | TOK_RX_ANY                     = //AnyNode();
              ;

Equals       : '='                          = generateLexerCode();
             ;

Type         :  TOK_TYPENAME                = {
                                                currentType = new Type($1);
                                                if (runtimeData.getTypes().contains(currentType)) {
                                                  currentType = runtimeData.getTypes().get(runtimeData.getTypes().indexOf(currentType));
                                                } else {
                                                  runtimeData.getTypes().add(currentType);
                                                }
                                              }
             |                              = currentType = null;
             ;


Productions  :  Productions TOK_TOKEN ':' Rules ';'  = if (!setLeftHandOfLastRule($2)) return false;
             |  TOK_TOKEN ':' Rules ';'              = if (!setLeftHandOfLastRule($1)) return false;
             ;

Rules        :  Rules '|' GrammarRule       = {
                                                newRule();
                                                bActionDone = false;
                                              }
             |  GrammarRule                 = {
                                                newRule();
                                                currentRuleIndex = runtimeData.getRules().size() - 1;
                                                bActionDone = false;
                                              }
             ;

GrammarRule  :  Rule
             |                              = {
                                                bActionDone = false;
                                              }
             ;

Rule         :  Rule Symbol
             |  Symbol
             ;

Symbol       :  TOK_TOKEN                    = {
                                                 if ($1.length() == 0) {
                                                   break;
                                                 }
                                                 if (isFirstToken) {
                                                   rulePrecedence = 0;
                                                   ruleAssociativity = Associativity.NONE;
                                                   isFirstToken = false;
                                                 }
                                                 if (bActionDone) {
                                                   Rule stx = newEmptyRule();
                                                   String rootName = "$code-fragment-" + (runtimeData.codeRule++);
                                                   NonTerminal codeFragment = new NonTerminal(rootName);
                                                   codeFragment.setCodeFragment(true);
                                                   runtimeData.getNonTerminals().add(codeFragment);
                                                   stx.setLeftHand(codeFragment);
                                                   codeFragment.setCount(codeFragment.getCount() + 1);
                                                   codeFragment.setPrecedence(1); /* used as non terminal */
                                                   newItem(codeFragment);
                                                   //stx.getItems().add(item);
                                                   bActionDone = false;
                                                 }
                                                 Symbol symbol;
                                                 NonTerminal nonTerminal = runtimeData.findNonTerminalByName($1);
                                                 if (nonTerminal == null) {
                                                   Terminal terminal = runtimeData.findTerminalByName($1);
                                                   if (terminal != null) {
                                                     rulePrecedence = terminal.getPrecedence();
                                                     ruleAssociativity = terminal.getAssociativity();
                                                     symbol = terminal;
                                                   } else {
                                                     if ($<mustClose>1 && $<value>1 >= 0) {
                                                       terminal = new Terminal($1);
                                                       runtimeData.getTerminals().add(terminal);
                                                       if ($<value>1 >= 0) {
                                                         for (Terminal cual : runtimeData.getTerminals()) {
                                                           if (cual != terminal && cual.getToken() == $<value>1) {
                                                             environment.error(-1, "Warning: Token number %d already used on token \'%s\'.",
                                                                 $<value>1, cual.getName());
                                                             return false;
                                                           }
                                                         }
                                                         terminal.setToken($<value>1);
                                                       }
                                                       symbol = terminal;
                                                     } else {
                                                       nonTerminal = new NonTerminal($1);
                                                       runtimeData.getNonTerminals().add(nonTerminal);
                                                       nonTerminal.setCount(nonTerminal.getCount() + 1);
                                                       symbol = nonTerminal;
                                                     }
                                                   }
                                                 } else {
                                                   symbol = nonTerminal;
                                                 }
                                                 newItem(symbol);
                                               }
             |  TOK_PREC TOK_TOKEN           = {
                                                 NonTerminal nonTerminal = runtimeData.findNonTerminalByName($2);
                                                 if (nonTerminal == null) {
                                                   Terminal terminal = runtimeData.findTerminalByName($2);
                                                   if (terminal == null) {
                                                     environment.error(-1, "Warning: token \'%s\' not declared.", $2);
                                                     return false;
                                                   } else {
                                                     rulePrecedence = terminal.getPrecedence();
                                                     ruleAssociativity = terminal.getAssociativity();
                                                   }
                                                 } else {
                                                   environment.error(-1, "Warning: token \'%s\' not declared.", $2);
                                                   return false;
                                                 }
                                               }
                                             
             |  '='                          = {
                                                 int i = runtimeData.currentRuleItems != null ? runtimeData.currentRuleItems.size() : 0;
                                                 if (!ruleAction(runtimeData.getRules().size(), i, currentNonTerminalName)) {
                                                   return false;
                                                 }
                                                 bActionDone = true;
                                               }
             ;

%%

  /**
   * Get next token
   * 
   * @return the next token, changing mode as needed
   */
  protected int parserElement(boolean init) {
    int rc;
  
    if (init) {
      getNextChar(init);
    }
    if (isRegex) {
      rc = getRegexSymbol();
      if (environment.isVerbose()) {
        System.out.printf("RegexScanner: %d\n", rc);
      }
    } else {
      rc = getNormalSymbol();
      lexicalValue = new StackElement(-1, tokenNumber, mustClose, runtimeData.currentStringValue, null);
      if (environment.isDebug()) {
        System.out.printf("* StdScanner: %s(%d) {%s}\n",
            getTokenName(rc), rc, lexicalValue != null ? lexicalValue.toString() : "");
      }
    }
    return rc;
  }

  /**
   * report an error
   * 
   * @param StxState state of the error
   * @param StxSym causing token
   * @param pStxStack the position in the stack when the error happened
   * @return
   */
  protected int parserError(int state, int sym, int stackTop, String errorMessage) {
    if (errorMessage != null) {
      environment.error(-1, "Syntax error %d :\'%s\'.", state, errorMessage);
    } else {
      System.err.printf("%s(%05d) : Unknown error on state %d\n", environment.getSourceFile().toString(),
          runtimeData.lineNumber + 1, state);
    }
    isError = true;
    return 0; /*
               * with actions, it recovers weird. Need to change the action
               * stuff to the scanner
               */
  }
  
  /**
   * Get the next character
   * @param init indicates if this is the first call
   */
  public char getNextChar(boolean init) {
    return getCharacter();
  }

  @Override
  public int getRegexSymbol() {
    char c2;
  
    if (isEqual) {
      isEqual = false;
      runtimeData.currentStringValue = "";
      return TOK_TOKEN;
    }
  
    if (runtimeData.currentCharacter == '|') {
      getCharacter();
      return TOK_RX_PIPE;
    }
    if (runtimeData.currentCharacter == '(') {
      getCharacter();
      return TOK_RX_LPAR;
    }
    if (runtimeData.currentCharacter == ')') {
      getCharacter();
      return TOK_RX_RPAR;
    }
    if (runtimeData.currentCharacter == '*') {
      getCharacter();
      return TOK_RX_STAR;
    }
    if (runtimeData.currentCharacter == '+') {
      getCharacter();
      return TOK_RX_PLUS;
    }
    if (runtimeData.currentCharacter == '?') {
      getCharacter();
      return TOK_RX_HUH;
    }
    if (runtimeData.currentCharacter == '.') {
      getCharacter();
      return TOK_RX_ANY;
    }
    if (runtimeData.currentCharacter == '/') {
      isRegex = false;
      isEqual = true;
      getCharacter();
      return '/';
    }
  
    if (runtimeData.currentCharacter == '\\') {
      getCharacter();
      c2 = decodeEscape();
      if (c2 == 0) {
        return '\0';
      }
    }
    /*
     * StxValue.node = malloc(sizeof(REGEXNODE)); StxValue.node.parent = NULL;
     * StxValue.node.child1 = NULL; StxValue.node.child2 = NULL;
     * StxValue.node.nodeType = NODE_LEX; StxValue.node.ranges =
     * malloc(sizeof(REGEXRANGE)); StxValue.node.ranges.next = NULL;
     * StxValue.node.ranges.prev = NULL; StxValue.node.ranges.charStart = c2;
     * StxValue.node.ranges.charEnd = c2;
     */
    return TOK_CHARS;
  }

  @Override
  public int getNormalSymbol() {
    char c2;
    String s2;
    boolean end;
  
    s2 = runtimeData.currentStringValue;
    runtimeData.currentStringValue = "";
  
    if (markers >= 2) {
      return 0;
    }
  
    if (isCurlyBrace) {
      isCurlyBrace = false;
      return ';';
    }
  
    if (isEqual) {
      isEqual = false;
      runtimeData.currentStringValue = "";
      return TOK_TOKEN;
    }
  
    while (2 > 1) {
      while (Character.isWhitespace(runtimeData.currentCharacter)) {
        getCharacter();
      }
      if (runtimeData.currentCharacter == '/') {
        if ((getCharacter()) == '*') {
          getCharacter();
          end = false;
          while (!end) {
            while (runtimeData.currentCharacter == '*') {
              if ((getCharacter()) == '/') {
                end = true;
              }
            }
            getCharacter();
          }
        } else {
          ungetCharacter(runtimeData.currentCharacter);
          runtimeData.currentCharacter = '/';
          break;
        }
      } else {
        break;
      }
    }
  
    if (runtimeData.currentCharacter == '\0') {
      return 0;
    }
  
    if (runtimeData.currentCharacter == '%' || runtimeData.currentCharacter == '\\') {
      getCharacter();
      switch (runtimeData.currentCharacter) {
        case '0':
          getCharacter();
          return TOK_TERM;
        case '<':
          getCharacter();
          return TOK_LEFT;
        case '2':
          getCharacter();
          return TOK_BINARY;
        case '>':
          getCharacter();
          return TOK_RIGHT;
        case '%':
        case '\\':
          getCharacter();
          markers++;
          return TOK_MARK;
        case '=':
          getCharacter();
          return TOK_PREC;
        case '@':
          getCharacter();
          return TOK_NAME;
        case '{':
          getCharacter();
          isCurlyBrace = true;
          return '{';
        case '!':
          getCharacter();
          return TOK_ERRDEF;
      }
      while (Character.isLetterOrDigit(runtimeData.currentCharacter)) {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      for (ReservedWord rw : reservedWords) {
        if (runtimeData.currentStringValue.equals(rw.word)) {
          if (rw.token == TOK_UNION) {
            isCurlyBrace = true;
          }
          return rw.token;
        }
      }
      isError = true;
      environment.error(-1, "Reserved word \'%s\' is incorrect.", runtimeData.currentStringValue);
      return TOK_ERROR;
    }
  
    if (runtimeData.currentCharacter == ';') {
      getCharacter();
      return ';';
    }
  
    if (runtimeData.currentCharacter == ',') {
      getCharacter();
      return ',';
    }
  
    if (runtimeData.currentCharacter == ':') {
      currentNonTerminalName = s2;
      getCharacter();
      return ':';
    }
  
    if (runtimeData.currentCharacter == '|') {
      getCharacter();
      return '|';
    }
  
    if (runtimeData.currentCharacter == '=') {
      getCharacter();
      isEqual = true;
      return '=';
    }
  
    if (runtimeData.currentCharacter == '{') {
      isEqual = true;
      return '=';
    }
  
    if (runtimeData.currentCharacter == '<') {
      getCharacter();
      runtimeData.currentStringValue = "";
      while (runtimeData.currentCharacter != '\0' && runtimeData.currentCharacter != '>' && runtimeData.currentCharacter != '\n') {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      if (runtimeData.currentCharacter != '>') {
        isError = true;
        environment.error(-1, "Statement < .. > not ended.");
        return TOK_ERROR;
      }
      getCharacter();
      return TOK_TYPENAME;
    }
  
    if (runtimeData.currentCharacter == '/') {
      isRegex = true;
      isEqual = true;
      getCharacter();
      return '/';
    }
  
    if (Character.isDigit(runtimeData.currentCharacter)) {
      runtimeData.currentStringValue = "";
      while (Character.isDigit(runtimeData.currentCharacter)) {
        runtimeData.currentStringValue += runtimeData.currentCharacter;
        getCharacter();
      }
      tokenNumber = Integer.parseInt(runtimeData.currentStringValue);
      return TOK_NUM;
    }
  
    mustClose = false;
    if (runtimeData.currentCharacter == '\'' || runtimeData.currentCharacter == '"') {
      c2 = runtimeData.currentCharacter;
      mustClose = true;
      getCharacter();
    } else {
      c2 = ':';
    }
  
    runtimeData.currentStringValue = "";
    do { /* TOKEN */
      runtimeData.currentStringValue += runtimeData.currentCharacter;
      getCharacter();
      if (runtimeData.currentCharacter == '\0') {
        break;
      }
      if (!mustClose && "%\\;,:|={< \r\t\n".indexOf(runtimeData.currentCharacter) >= 0) {
        break;
      }
    } while (runtimeData.currentCharacter != c2);
  
    if (mustClose && runtimeData.currentCharacter != c2) {
      isError = true;
      environment.error(-1, "Statement ' .. ' or \" .. \" not ended.");
      return TOK_ERROR;
    }
    tokenNumber = -1;
    if (runtimeData.currentStringValue.equals("\\a")) {
      tokenNumber = 7;
    } else if (runtimeData.currentStringValue.equals("\\b")) {
      tokenNumber = '\b';
    } else if (runtimeData.currentStringValue.equals("\\n")) {
      tokenNumber = '\n';
    } else if (runtimeData.currentStringValue.equals("\\t")) {
      tokenNumber = '\t';
    } else if (runtimeData.currentStringValue.equals("\\f")) {
      tokenNumber = '\f';
    } else if (runtimeData.currentStringValue.equals("\\r")) {
      tokenNumber = '\r';
    } else if (runtimeData.currentStringValue.length() >= 2 && runtimeData.currentStringValue.substring(0, 2).equals("\\x")) {
      int p = 2;
      tokenNumber = 0;
      while (2 > 1) {
        if (runtimeData.currentStringValue.charAt(p) >= '0' && runtimeData.currentStringValue.charAt(p) <= '9') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - '0';
        } else if (runtimeData.currentStringValue.charAt(p) >= 'A' && runtimeData.currentStringValue.charAt(p) <= 'F') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - 'A' + 10;
        } else if (runtimeData.currentStringValue.charAt(p) >= 'a' && runtimeData.currentStringValue.charAt(p) <= 'f') {
          tokenNumber = tokenNumber * 16 + runtimeData.currentStringValue.charAt(p++) - 'a' + 10;
        } else {
          break;
        }
      }
    } else if (runtimeData.currentStringValue.length() >= 2 && runtimeData.currentStringValue.substring(0, 2).equals("\\0")) {
      int p = 2;
      tokenNumber = 0;
      while (runtimeData.currentStringValue.charAt(p) >= '0' && runtimeData.currentStringValue.charAt(p) <= '7') {
        tokenNumber = tokenNumber * 8 + runtimeData.currentStringValue.charAt(p++) - '0';
      }
    }
  
    if (mustClose) {
      getCharacter();
      if (runtimeData.currentStringValue.length() == 1) {
        tokenNumber = runtimeData.currentStringValue.charAt(0);
      }
    }
  
    return TOK_TOKEN;
  }

  /**
   * Execute this phase
   * @throws ParsingException on error.  Check cause and message.
   */
  public void execute() throws ParsingException {
    if (environment.isVerbose()) {
      System.out.println("Parse");
    }
    setVerbose(environment.isDebug());
    runtimeData.lineNumber = 0;
    markers = 0;
    Terminal terminal = new Terminal("$");
    runtimeData.getTerminals().add(terminal);
    terminal.setCount(0);
    terminal.setToken(0);
    if (parse() == 0 || isError) {
      throw new ParsingException("Parser returned errors.  Please see messages from parser");
    }
    reviewDeclarations();
    computeRootSymbol();
    generateTopRecoveryTable();
    finalizeSymbols();
    finalizeRules();
    generateTokenDefinitions();
    runtimeData.setNumberOfErrors(errorCount);
    runtimeData.setFinalActions(finalActions);
  }
  
  static class ReservedWord {
    String word;
    int token;

    ReservedWord(String word, int token) {
      super();
      this.word = word;
      this.token = token;
    }
  }
  
  static final ReservedWord reservedWords[] = { 
    new ReservedWord("token", TOK_TERM),
    new ReservedWord("term", TOK_TERM), 
    new ReservedWord("left", TOK_LEFT), 
    new ReservedWord("nonassoc", TOK_BINARY),
    new ReservedWord("binary", TOK_BINARY),
    new ReservedWord("right", TOK_RIGHT), 
    new ReservedWord("prec", TOK_PREC),
    new ReservedWord("start", TOK_START), 
    new ReservedWord("type", TOK_TYPE), 
    new ReservedWord("union", TOK_UNION),
    new ReservedWord("stack", TOK_UNION), 
    new ReservedWord("class", TOK_UNION),
    new ReservedWord("struct", TOK_UNION),
    new ReservedWord("name", TOK_NAME), 
    new ReservedWord("error", TOK_ERRDEF), 
    new ReservedWord("lexer", TOK_LEXER)
  };
  
}